#include <lit_pixel_uniforms.fxh>
#include <light_uniforms.fxh>
#include <math.fxh>

#define READ_LIGHTS
#define READ_CLUSTER_DATA_GRID
#include <cluster.fxh>

#include <noise.fxh>
#include <lighting.fxh>

Texture2DArray g_Texture;
SamplerState   g_Texture_sampler;

Texture2DArray g_Normal;
SamplerState   g_Normal_sampler;

Texture2DArray g_Specular;
SamplerState   g_Specular_sampler;

Texture2DArray g_Emission;
SamplerState   g_Emission_sampler;

struct PSInput {
    float4 Pos                      : SV_POSITION;
    float4 WorldPos                 : POSITION1;

    float4 Normal                   : NORMAL0;
    float4 Tangent                  : TANGENT0;

    float2 UV                       : TEX_COORD;
    float4 Color                    : COLOR0;

    nointerpolation float  TexIndex : TEX_ARRAY_INDEX;
};

struct PSOutput {
    float4 Color : SV_TARGET;
};

float3x3 CreateTangentToWorld(float3 normal, float4 tangent) {
	float3 T = tangent.xyz;
	float3 B = cross(normal, T) * tangent.w;

	float3x3 TBN = float3x3(T, B, normal);
	return TBN;
}

// Unpacks a 2 channel BC5 normal to xyz
float3 UnpackBC5Normal(float2 packedNormal) {
	return float3(packedNormal, sqrt(1 - saturate(dot(packedNormal.xy, packedNormal.xy))));
}

float3 TangentSpaceNormalMapping(float3 sampledNormal, float3x3 TBN) {
	// Flip Y
	//sampledNormal.y = 1 - sampledNormal.y;

	float3 normal = UnpackBC5Normal(sampledNormal.xy);
	normal.xy = sampledNormal.xy * 2.0f - 1.0f;
	normal = normalize(normal);
	return mul(normal, TBN);
}

void main(in PSInput PSIn, out PSOutput PSOut) {
    float4 diffuseTS = g_Texture.Sample(g_Texture_sampler, float3(PSIn.UV, PSIn.TexIndex)) * PSIn.Color;
    if (diffuseTS.a <= 0.0) discard;

    // NORMAL -----
	float3 normalTS = g_Normal.Sample(g_Normal_sampler, float3(PSIn.UV, PSIn.TexIndex)).rgb;
	float3x3 TBN    = CreateTangentToWorld(PSIn.Normal.xyz, float4(normalize(PSIn.Tangent.xyz), PSIn.Tangent.w));
    float3 normal   = TangentSpaceNormalMapping(normalTS, TBN);
    // -------------

	float4 specularTS = g_Specular.Sample(g_Specular_sampler, float3(PSIn.UV, PSIn.TexIndex)) * PSIn.Color;
	float4 emissionTS = g_Emission.Sample(g_Emission_sampler, float3(PSIn.UV, PSIn.TexIndex)) * PSIn.Color;

    // LIGHT ------
	float3 V           = normalize(g_cameraPos.xyz - PSIn.WorldPos);
	float dither       = InterleavedGradientNoise(PSIn.Pos.xy);

    float3 specular    = ComputeF0(specularTS.rgb, diffuseTS.rgb, MetalPower);
    float3 diffuse     = ComputeDiffuseColor(diffuseTS.rgb, MetalPower);

    LightResult result = ApplyLight(specular, RoughtnessPower, diffuse, normal, V, PSIn.WorldPos.xyz, PSIn.Pos, dither);

	float3 outRadiance = 0;
	outRadiance += result.Diffuse + result.Specular;
	outRadiance += emissionTS.rgb * EmissionPower;

    /*
	outRadiance += ambientOcclusion * Diffuse_Lambert(brdfData.Diffuse) * SampleDDGIIrradiance(input.PositionWS, surface.Normal, -V);
	outRadiance += lighting.Diffuse + lighting.Specular;
	outRadiance += ssr * ambientOcclusion;
	outRadiance += surface.Emissive;
    */
    // ------------

    PSOut.Color.rgb = outRadiance;
    PSOut.Color.a = diffuseTS.a;
}
