
#include <unlit_pixel_uniforms.fxh>

#ifdef CLUSTER_PLUGIN
    #include <camera.fxh>

    #include <decal_uniforms.fxh>

    #define READ_DECALS
    #define READ_CLUSTER_DATA_GRID
    #include <cluster.fxh>
#endif

Texture2DArray g_Textures[];
SamplerState   g_Textures_sampler;

#ifdef CLUSTER_PLUGIN
    #include <decaling.fxh>
#endif

struct PSInput {
    float4 Pos                      : SV_POSITION;
    float4 WorldPos                 : POSITION1;

    float2 UV                       : TEX_COORD;
    float4 Color                    : COLOR0;

    nointerpolation uint   TexIndex : TEX_ARRAY_INDEX;
};

struct PSOutput {
    float4 Color : SV_TARGET;
};

void main(in PSInput PSIn, out PSOutput PSOut) {
    float4 color = g_Textures[Constants.textureID].Sample(g_Textures_sampler, float3(PSIn.UV, PSIn.TexIndex)) * PSIn.Color;
    if (color.a <= 0.0) discard;

    #ifdef CLUSTER_PLUGIN
        // Apply compute data ----
        uint3 clusterIndex3D = uint3(floor(PSIn.Pos.xy / float2(CLUSTER_TEXTEL_SIZE, CLUSTER_TEXTEL_SIZE)), GetSliceFromDepth(PSIn.Pos.w));
        uint tileIndex = Flatten3D(clusterIndex3D, float2(CLUSTERS_X, CLUSTERS_Y));
        uint gridOffset = tileIndex * CLUSTERED_NUM_BUCKETS;

        float3 ddxPos = ddx(PSIn.WorldPos.xyz);
        float3 ddyPos = ddy(PSIn.WorldPos.xyz);

        for(uint bucketIndex = 0; bucketIndex < CLUSTERED_NUM_BUCKETS; ++bucketIndex) {
            uint buckets = ClusterDataGrid[gridOffset + bucketIndex].y;

            // Apply decals ---
            float4 roughtness = 0;
            ApplyDecals(buckets, bucketIndex, PSIn.WorldPos, ddxPos, ddyPos, color, roughtness);
            // ----------------
        }
    #endif

    PSOut.Color = color;
}
