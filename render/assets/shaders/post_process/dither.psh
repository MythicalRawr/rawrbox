Texture2D    g_Texture;
SamplerState g_Texture_sampler; // By convention, texture samplers must use the '_sampler' suffix

Texture2D    g_Dither;
SamplerState g_Dither_sampler; // By convention, texture samplers must use the '_sampler' suffix

cbuffer Constants {
    // GLOBAL ----
    float4   g_ScreenSize;
    // ------------

    // UNIFORMS ----
    float4   g_DitherSettings;
    // ------------
};

#define ditherSize g_DitherSettings.x
#define ditherThreshold g_DitherSettings.y
#define ditherDepth g_DitherSettings.z
#define ditherIntensity g_DitherSettings.w

#define ditherColorDepth 2.

struct PSInput {
    float4 Pos   : SV_POSITION;
    float2 UV    : TEX_COORD;
};

struct PSOutput {
    float4 Color : SV_TARGET;
};

void main(in PSInput PSIn, out PSOutput PSOut) {
#if defined(DESKTOP_GL) || defined(GL_ES)
    float2 UV = float2(PSIn.UV.x, 1.0 - PSIn.UV.y);
#else
    float2 UV = PSIn.UV;
#endif

    float4 Color = g_Texture.Sample(g_Texture_sampler, UV);

    // Dither -----
	float luma = dot(Color.rgb, float3(0.21267290f, 0.71515220f, 0.07217500f));

    if(ditherSize!= 0.0) { // FAST MODE
		float4 ditherTex = g_Dither.Sample(g_Dither_sampler, UV.xy * ditherSize * g_ScreenSize.zw);
		float dither = (ditherTex.a - 0.5) * 2.0 / ditherThreshold;

	    Color.rgb *= 1.0f + (luma < dither ? (1.0 - luma) * (1.0 - (ditherColorDepth / 24.0)) * ditherIntensity * 10.0 : 0.0) * (1.0 / ditherDepth);
	} else {
		Color.rgb = getDither(UV.xy * g_ScreenSize.zw, Color.rgb, ditherIntensity * ditherDepth * 1.0 / 3.0);
	}

    PSOut.Color = Color;
}
